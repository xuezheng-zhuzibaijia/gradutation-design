#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <libpmemobj.h>
#include "btree.h"
/*
 *binary_search_exact--(interval)return index of key in the keys,if not exists,return -1
 */
static int binary_search_exact(node_pointer n,int key){
    int left = 0,right = D_RO(n)->num_keys - 1;
    while(left<=right)
    {
        int mid = (left+right)/2;
        if(D_RO(n)->keys[mid]==key)
        {
            return mid;
        }
        if(D_RO(n)->keys[mid]>key)
        {
            right = mid-1;
        }
        else
        {
            left = mid+1;
        }
    }return -1;
}
/*
 *binary_search--(interval) return the index of pointers,which may include the key
 */
static int binary_search(node_pointer n,int key){

    int left = 0,right = D_RO(n)->num_keys - 1;
    while(left <= right){
        int mid = (left + right)/2;
        if(D_RO(n)->num_keys[mid] > key){
            right =  mid - 1;
        }else{
            left = mid + 1;
        }
    }return left;
}
//Output
/*
 *find_leaf--return the leaf which may contain the key
 */
node_pointer find_leaf(node_pointer root,int key){
   node_pointer c = root;
   if(TOID_IS_NULL(c)){
       return c;
   }while(!D_RO(c)->is_leaf){
       int index =  binary_search(c,key);
       TOID_ASSIGN(c,D_RO(c)->pointers[index]);
   }return c;
}
/*
 *find--return the value of key if exists,else return OID_NULL
 */
PMEMoid find(node_pointer root,int key){
    node_pointer leaf = find_leaf(root,key);
    int index = binary_search_exact(leaf,key);
    return (index==-1)?OID_NULL:leaf->pointers[index];
}
//Insertion
/*
 *make_node--return TOID(struct tree_node) point to a new allocated node
 */
node_pointer make_node(){
    node_pointer n = TX_NEW(struct tree_node);
    TX_SET(n,is_leaf,FALSE);
    TX_SET(n,num_keys,0);
    TX_SET(n,parent,TOID_NULL);
    return n;
}
/*
 *make_leaf--same as make_node except return a pointer pointing to leaf
 */
node_pointer make_leaf(){
    node_pointer leaf = make_node();
    TX_SET(leaf,is_leaf,TRUE);
    TX_SET(leaf,pointers[BTREE_ORDER-1],OID_NULL);
    return leaf;
}
/*
 *insert_into_leaf--insert key/value to leaf then return leaf,in this situation the leaf don't need to split
 */
node_pointer insert_into_leaf( node_pointer leaf,int key,PMEMoid value){
    int index = binary_search(leaf,key);
    for(int i = D_RO(leaf)->num_keys-1;i >= index;--i){
        TX_SET(leaf,keys[i+1],D_RO(leaf)->keys[i]);
        TX_SET(leaf,pointers[i+1],D_RO(leaf)->pointers[i]);
    }
    TX_SET(leaf,keys[index],key);
    TX_SET(leaf,pointers[index],value);
    TX_SET(leaf,num_keys,D_RO(leaf)->num_keys+1);
    return leaf;
}
/*
 *cut--get the index where to split
 */
int cut(int length){
    return (length%2==0)?(length/2):(length/2+1);
}
/*
 *insert_into_leaf_after_splitting--insert key/value to leaf then cause the leaf splitting
 */
node_pointer insert_into_leaf_after_splitting( node_pointer root,node_pointer leaf,int key,PMEMoid value){
    node_pointer new_leaf;
    new_leaf = make_leaf();
    int split_index = cut(BTREE_ORDER),index = binary_search(leaf,key);
    for(int i = 0,j = split_index;j < D_RO(leaf)->num_keys;j++,i++){
        TX_SET(new_leaf,keys[i],D_RO(leaf)->keys[j]);
        TX_SET(new_leaf,pointers[i],D_RO(leaf)->pointers[j]);
    }
    TX_SET(leaf,num_keys,split_index);
    TX_SET(new_leaf,num_keys,D_RO(leaf)->num_keys-split_index);
    if(index<split_index){
        insert_into_leaf(leaf,key,value);
    }else{
        insert_into_leaf(new_leaf,key,value);
    }
    TX_SET(new_leaf,pointers[BTREE_ORDER-1],D_RO(leaf)->pointers[BTREE_ORDER-1]);
    TX_SET(leaf,pointers[BTREE_ORDER-1],leaf.oid);
    return insert_into_parent(root,left,key,new_leaf);
}
/*
 *insert_into_node--sample as insert_into_leaf,but not to a leaf instead of a interval node
 */
node_pointer insert_into_node(node_pointer root,node_pointer n,int key,node_pointer child){
    int index = binary_search(n,key);
    for(int i = D_RO(n)->num_keys-1;i >= index;--i){
        TX_SET(n,keys[i+1],D_RO(n)->keys[i]);
        TX_SET(n,pointers[i+2],D_RO(n)->pointers[i+1]);
    }TX_SET(n,keys[index],key);
    TX_SET(n,pointers[index+1],child.oid);
    TX_SET(child,parent,n);
    return root;
}
/*
 *insert_into_node_after_splitting--sample as insert_into_leaf_after_splitting,but not to a leaf instead of a interval node
 */
node_pointer insert_into_node_after_splitting(node_pointer root,node_pointer n,int key,node_pointer child){
    node_pointer new_n = make_node(),temp;
    int split_index = cut(BTREE_ORDER),index = binary_search(n,key);
    int new_key = D_RO(n)->keys[split_index];
    for(int i=0,j = split_index+1;j < D_RO(n)->num_keys;j++,i++){
        TX_SET(new_n,keys[i],D_RO(n)->keys[j]);
        TX_SET(new_n,pointers[i],D_RO(n)->pointers[j]);
        TOID_ASSIGN(temp,D_RO(new_n)->pointers[i]);
        TX_SET(temp,parent,new_n);
    }
    TX_SET(n,num_keys,split_index);
    TX_SET(new_n,num_keys,D_RO(n)->num_keys-split_index-1);
    TX_SET(new_n,pointers[D_RO(new_n)->num_keys],D_RO(n)->pointers[split_index]);
    TOID_ASSIGN(temp,D_RO(new_n)->pointers[D_RO(new_n)->num_keys]);
    TX_SET(temp,parent,new_n);
    if(index<split_index){
        insert_into_node(root,n,key,child);
    }else{
        insert_into_node(root,new_n,child);
    }
    return insert_into_parent(root,left,new_key,new_n);
}
/*
 *insert_into_parent--insert a new child to parent
 *return root
 */
node_pointer insert_into_parent(node_pointer root,node_pointer left,int key,node_pointer right){
    node_pointer parent = D_RO(left)->parent;
    if(TOID_IS_NULL(parent)){
        return insert_into_new_root(left,key,right);
    }else{
        TX_SET(right,parent,parent);
        if(D_RO(parent)->num_keys < BTREE_ORDER){
            insert_into_node(root,parent,key,right);
        }else{
            insert_into_node_after_splitting(root,parent,key,right);
        }
    }return root;
}
/*
 *insert_into_new_root--build a new root contains two children
 */
node_pointer insert_into_new_root(node_pointer left,int key,node_pointer right){
    node_pointer root = make_node();
    TX_SET(root,num_keys,1);
    TX_SET(root,pointers[0],left.oid);
    TX_SET(root,pointers[1],right.oid);
    TX_SET(left,parent,root);
    TX_SET(right,parent,root);
    return root;
}
/*
 *start_new_tree--build a leaf as root
 */
node_pointer start_new_tree(int key,PMEMoid value){
    node_pointer root = make_leaf();
    TX_SET(root,keys[0],key);
    TX_SET(root,pointers[0],value);
    TX_SET(root,num_keys,1);
    return root;
}
/*
 *tree_insert--the 
 */
node_pointer tree_insert(node_pointer root,int key,PMEMoid value){
    if(!OID_IS_NULL(find(root,key))){
        return root;
    }
    if(TOID_IS_NULL(root)){
        return start_new_tree(key,value);
    }node_pointer leaf = find_leaf(root,key);
    if(D_RO(leaf)->num_keys < BTREE_ORDER){
        leaf = insert_into_leaf(leaf,key,value);
        return root;
    }return insert_into_leaf_after_splitting(root,leaf,key,value);
}
//Deletion
int get_neighbor_index(node_pointer n);
node_pointer adjust_root(node_pointer root);
node_pointer coalesce_nodes(node_pointer root,node_pointer n,node_pointer neighbor,int neighbor_index,int k_prime);
node_pointer redistribute_nodes(node_pointer root,node_pointer n,node_pointer neighbot,int neighbor_index,int k_prime,int k_prime_index);
node_pointer delete_entry(node_pointer root,node_pointer n,int key);
node_pointer tree_delete(node_pointer root,int key);
